🧠 CONTEXT ENGINEERING FRAMEWORK
markdown# File: .trae/context-framework.md

## Phase-Based Problem Solving

### PHASE 1: DISCOVERY (Understanding)
When user reports an issue, ALWAYS start here:

1. **Clarify the Problem**
   Questions to ask:
   - What exactly isn't working? (be specific)
   - What did you expect to happen?
   - What actually happened?
   - When did this start occurring?
   - Can you reproduce it consistently?

2. **Gather Context**
   Information to collect:
   - Which part of the site? (customer, admin, both)
   - Which page/component specifically?
   - Any error messages? (console, network, UI)
   - What data is involved? (products, orders, users)

3. **Map the Flow**
   Trace the path:
   - User action → Component → Service → API → Database
   - Identify where in this chain the issue occurs
   - Note: Often the error shows in UI but originates in backend

### PHASE 2: ANALYSIS (Root Cause)
Investigate systematically:

1. **Frontend Investigation**
   Check:
```bash
   # Find the component
   fd -e tsx -e jsx "ComponentName" frontend/src
   
   # Check service calls
   grep -r "serviceName\." frontend/src/components
   
   # Look for error handling
   grep -r "catch\|error" [component-file]
```

2. **Backend Investigation**
   Check:
```bash
   # Find the route
   grep -r "router\.\(get\|post\|put\|delete\)" backend/src/routes
   
   # Check controller
   cat backend/src/controllers/[resource]Controller.ts
   
   # Check service
   cat backend/src/services/[resource]Service.ts
   
   # Check database schema
   cat prisma/schema.prisma | grep -A 20 "model [Resource]"
```

3. **Data Flow Investigation**
   Verify:
   - Request payload format matches backend expectations
   - Response structure matches frontend expectations
   - Database schema supports the operations
   - Types are consistent across layers

4. **Common Root Causes**
   - **Mock data**: Component using hardcoded array instead of API
   - **Route mismatch**: Frontend calls /api/products but backend has /api/v1/products
   - **Missing middleware**: Auth not applied, validation skipped
   - **Type mismatch**: Frontend expects string but backend returns number
   - **Error swallowing**: Catch block that doesn't propagate error
   - **State not updating**: Missing setState or Zustand action

### PHASE 3: SOLUTION DESIGN (Planning)
Before coding, design the fix:

1. **Identify Changes Needed**
   Example format:
To fix: Products not loading on homepage
Changes:

frontend/src/app/page.tsx

Remove: const products = mockProducts
Add: Fetch from productService.getProducts()
Add: Loading and error states


frontend/src/services/productService.ts

Verify: getProducts() calls correct endpoint
Add: Error handling with retry logic


backend/src/routes/products.ts

Verify: GET /api/v1/products route exists
Check: No auth middleware blocking public access


backend/src/services/productService.ts

Verify: Returns products with correct structure
Add: Pagination support




2. **Assess Impact**
   - Will this change break other features?
   - Do other components use the same pattern?
   - Should we fix them all at once or incrementally?
   - Does this require a database migration?

3. **Get Approval**
   Present to user:
I've identified the issue and here's my plan:
Problem: [concise description]
Root cause: [what's actually wrong]
Proposed fix: [what I'll change]
Files affected: [list]
Risk level: Low/Medium/High
Should I proceed with this approach?

### PHASE 4: IMPLEMENTATION (Fixing)
Execute with precision:

1. **Read Before Write**
```typescript
   // ALWAYS read the current file first
   const currentContent = await readFile('path/to/file.tsx');
   
   // Understand the existing patterns
   // Then make targeted changes
```

2. **Make Minimal Changes**
   - Change only what's necessary
   - Keep existing patterns
   - Don't refactor unrelated code
   - Preserve comments and formatting

3. **Maintain Type Safety**
```typescript
   // If changing an interface
   interface Product {
     id: string;
     name: string;
     // OLD: price: number;
     // NEW: price: number | string; // Support both during migration
   }
   
   // Update all usages gradually
```

4. **Add Error Handling**
```typescript
   // Frontend service
   async getProducts(): Promise<Product[]> {
     try {
       const response = await fetch(`${API_URL}/api/v1/products`);
       
       if (!response.ok) {
         throw new Error(`HTTP ${response.status}: ${response.statusText}`);
       }
       
       const data = await response.json();
       return data.products || data; // Handle different response shapes
     } catch (error) {
       console.error('Failed to fetch products:', error);
       throw error; // Re-throw so component can handle
     }
   }
```

5. **Update Related Code**
   If you change:
   - API response → Update frontend types
   - Database schema → Update Prisma types
   - Service function → Update all callers
   - Component props → Update parent components

### PHASE 5: VERIFICATION (Testing)
Don't assume it works:

1. **Self-Test Checklist**
☐ Code compiles (no TypeScript errors)
☐ Backend starts without errors
☐ Frontend builds successfully
☐ API endpoint responds correctly (test with curl/Postman)
☐ Frontend displays data correctly
☐ Error cases handled (network error, 404, 500)
☐ No console errors in browser
☐ No new warnings introduced

2. **Provide Test Instructions**
```markdown
   To verify the fix:
   
   1. Start backend: cd backend && npm run dev
   2. Start frontend: cd frontend && npm run dev
   3. Navigate to: http://localhost:3001/products
   4. Expected: Product list loads from API
   5. Test error: Stop backend, refresh page → Should show error message
```

3. **Rollback Plan**
If this causes issues:

Revert commit: git revert [commit-hash]
Or restore backup: git checkout HEAD~1 [file]


---

## 🎯 Specialized Scenarios

### Scenario: Replacing Mock Data with Real API

**Detection Signs:**
- Arrays defined with const mockProducts = [...]
- Import from '@/data/mockData'
- Comments like "TODO: Replace with API"

**Fix Process:**
1. Locate the mock data usage
2. Identify the real API endpoint needed
3. Create/verify service function exists
4. Replace mock with API call + loading/error states
5. Remove mock data import
6. Test with real backend

**Example:**
```typescript
// BEFORE (Mock)
const ProductList = () => {
  const products = mockProducts;
  return <div>{products.map(p => <ProductCard {...p} />)}</div>;
};

// AFTER (Real API)
const ProductList = () => {
  const [products, setProducts] = useState<Product[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  
  useEffect(() => {
    const loadProducts = async () => {
      try {
        setLoading(true);
        const data = await productService.getProducts();
        setProducts(data);
      } catch (err) {
        setError('Failed to load products');
        console.error(err);
      } finally {
        setLoading(false);
      }
    };
    
    loadProducts();
  }, []);
  
  if (loading) return <LoadingSpinner />;
  if (error) return <ErrorMessage message={error} />;
  
  return <div>{products.map(p => <ProductCard key={p.id} {...p} />)}</div>;
};
```

### Scenario: Fixing Route Mismatches

**Detection Signs:**
- 404 errors in network tab
- Frontend calls /api/products but backend has /api/v1/products
- Hardcoded URLs in components

**Fix Process:**
1. Standardize on ONE convention (recommend /api/v1/*)
2. Update all backend routes to follow convention
3. Update all frontend service calls
4. Use environment variable for base URL
5. Document the convention

**Example:**
```typescript
// backend/src/server.ts
app.use('/api/v1', v1Router); // Prefix all routes with /api/v1

// backend/src/routes/index.ts
router.use('/products', productsRouter);
router.use('/orders', ordersRouter);
// Results in /api/v1/products, /api/v1/orders

// frontend/src/lib/config.ts
export const API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3000';

// frontend/src/services/productService.ts
import { API_BASE_URL } from '@/lib/config';

export const productService = {
  async getProducts() {
    const response = await fetch(`${API_BASE_URL}/api/v1/products`);
    // ...
  }
};
```

### Scenario: Inconsistent Types Across Stack

**Detection Signs:**
- TypeScript errors about incompatible types
- Runtime errors accessing undefined properties
- Data exists but UI shows "undefined"

**Fix Process:**
1. Define source of truth (usually database schema)
2. Generate types from Prisma
3. Share types between backend and frontend
4. Update all usages

**Example:**
```typescript
// prisma/schema.prisma
model Product {
  id          Int      @id @default(autoincrement())
  name        String
  price       Decimal
  createdAt   DateTime @default(now())
}

// After `npx prisma generate`, use Prisma types:

// backend/src/controllers/productController.ts
import { Product } from '@prisma/client';

export const getProducts = async (): Promise<Product[]> => {
  return await prisma.product.findMany();
};

// shared/types/product.ts (or copy to frontend)
export type Product = {
  id: number;
  name: string;
  price: number; // Decimal converted to number for frontend
  createdAt: string; // DateTime converted to ISO string
};

// frontend/src/services/productService.ts
import { Product } from '@/types/product';

export const productService = {
  async getProducts(): Promise<Product[]> {
    const response = await fetch(`${API_BASE_URL}/api/v1/products`);
    const data = await response.json();
    return data.products;
  }
};
```

---

## 🔍 Debugging Toolkit

### Commands to Run
```bash
# Check if backend is running
curl http://localhost:3000/api/v1/health

# Test a specific endpoint
curl http://localhost:3000/api/v1/products | jq

# Check for TypeScript errors
cd backend && npx tsc --noEmit
cd frontend && npx tsc --noEmit

# Find all TODO/FIXME comments
grep -r "TODO\|FIXME" backend/src frontend/src

# Find mock data usage
grep -r "mock" --include="*.ts" --include="*.tsx" frontend/src

# Find hardcoded URLs
grep -r "http://\|https://" --include="*.ts" --include="*.tsx" frontend/src

# Check middleware order
cat backend/src/server.ts | grep "app.use"

# Verify route registrations
grep -r "router\.\(get\|post\|put\|delete\)" backend/src/routes
```

### Log Analysis
```typescript
// Add strategic logging
console.log('[DEBUG] Component mounted');
console.log('[DEBUG] Fetching products from:', url);
console.log('[DEBUG] Response:', response);
console.log('[DEBUG] State updated:', products);

// Check browser console
// Check backend terminal logs
// Check network tab (Chrome DevTools)
```

---

## 📚 Knowledge Base

### Quick Reference

**API Status Codes:**
- 200: OK (success)
- 201: Created (resource created)
- 400: Bad Request (invalid input)
- 401: Unauthorized (not logged in)
- 403: Forbidden (logged in but no permission)
- 404: Not Found (endpoint or resource doesn't exist)
- 500: Internal Server Error (backend crashed)

**Common Prisma Queries:**
```typescript
// Get all
await prisma.product.findMany();

// Get one
await prisma.product.findUnique({ where: { id } });

// Create
await prisma.product.create({ data: { ... } });

// Update
await prisma.product.update({ where: { id }, data: { ... } });

// Delete
await prisma.product.delete({ where: { id } });

// With relations
await prisma.product.findMany({ include: { category: true } });

// Transaction
await prisma.$transaction([
  prisma.product.update(...),
  prisma.inventory.update(...),
]);
```

**Zustand Store Pattern:**
```typescript
import { create } from 'zustand';

interface Store {
  items: Item[];
  addItem: (item: Item) => void;
  removeItem: (id: string) => void;
}

export const useStore = create<Store>((set) => ({
  items: [],
  addItem: (item) => set((state) => ({ items: [...state.items, item] })),
  removeItem: (id) => set((state) => ({ 
    items: state.items.filter(i => i.id !== id) 
  })),
}));
```

**React Query Pattern (if used):**
```typescript
import { useQuery, useMutation } from '@tanstack/react-query';

// Fetch
const { data, isLoading, error } = useQuery({
  queryKey: ['products'],
  queryFn: productService.getProducts,
});

// Mutate
const mutation = useMutation({
  mutationFn: productService.createProduct,
  onSuccess: () => queryClient.invalidateQueries(['products']),
});
```

---

## 🚀 Agent Activation Checklist

Before starting work, verify:
- [ ] Project root located and confirmed
- [ ] Backend and frontend directories identified
- [ ] Database connection working (if applicable)
- [ ] Environment variables documented
- [ ] User's current issue clearly understood
- [ ] Relevant files located
- [ ] Permission to make changes obtained

Remember: **Ask, don't assume. Verify, don't guess. Fix precisely, don't refactor randomly.**